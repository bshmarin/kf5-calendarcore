From c4a696ad8c4b8d51f6b46638a5b83618f5e00e7a Mon Sep 17 00:00:00 2001
From: Damien Caliste <dcaliste@free.fr>
Date: Tue, 14 May 2019 11:35:15 +0200
Subject: [PATCH 1/2] Adjust for lower Qt versions.

---
 CMakeLists.txt                   |  6 +++---
 autotests/testmemorycalendar.cpp |  2 +-
 autotests/testrecurtodo.cpp      |  5 +++++
 src/CMakeLists.txt               | 35 ++++++++++++++++----------------
 src/calendar.cpp                 |  1 +
 src/icalformat.cpp               |  1 +
 src/icalformat_p.cpp             |  3 +++
 src/memorycalendar.cpp           |  4 ++--
 src/occurrenceiterator.cpp       |  1 +
 src/recurrence.cpp               |  2 --
 src/recurrence.h                 |  5 -----
 src/recurrencerule.cpp           | 32 +++++++++++++++++++++++++++++
 src/utils_p.h                    |  8 ++++++++
 13 files changed, 75 insertions(+), 30 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index ecf1986ca..413cd71ee 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -5,19 +5,19 @@ project(KCalendarCore VERSION ${KF5_VERSION})
 
 # ECM setup
 include(FeatureSummary)
-find_package(ECM 5.67.0  NO_MODULE)
+find_package(ECM 5.44.0  NO_MODULE)
 set_package_properties(ECM PROPERTIES TYPE REQUIRED DESCRIPTION "Extra CMake Modules." URL "https://commits.kde.org/extra-cmake-modules")
 feature_summary(WHAT REQUIRED_PACKAGES_NOT_FOUND FATAL_ON_MISSING_REQUIRED_PACKAGES)
 
 set(CMAKE_MODULE_PATH ${ECM_MODULE_PATH} ${CMAKE_SOURCE_DIR}/cmake)
 
-set(REQUIRED_QT_VERSION 5.12.0)
+set(REQUIRED_QT_VERSION 5.6.0)
 
 include(KDEInstallDirs)
 include(KDECMakeSettings)
 include(KDEFrameworkCompilerSettings NO_POLICY_SCOPE)
 
-include(ECMGenerateExportHeader)
+include(GenerateExportHeader)
 include(ECMGenerateHeaders)
 include(ECMGeneratePriFile)
 
diff --git a/autotests/testmemorycalendar.cpp b/autotests/testmemorycalendar.cpp
index 77241eb43..6a424b2f1 100644
--- a/autotests/testmemorycalendar.cpp
+++ b/autotests/testmemorycalendar.cpp
@@ -121,7 +121,7 @@ void MemoryCalendarTest::testIncidences()
 
     QVERIFY(store.load());
     Todo::Ptr todo = cal->incidence(QStringLiteral("4")).staticCast<Todo>();
-    QVERIFY(todo->uid() == QLatin1Char('4'));
+    QCOMPARE(todo->uid(), QStringLiteral("4"));
     QVERIFY(todo->summaryIsRich());
     QVERIFY(todo->locationIsRich());
     cal->close();
diff --git a/autotests/testrecurtodo.cpp b/autotests/testrecurtodo.cpp
index a9d439888..6bacabff1 100644
--- a/autotests/testrecurtodo.cpp
+++ b/autotests/testrecurtodo.cpp
@@ -149,7 +149,12 @@ void RecurTodoTest::testRecurTodo_data()
     QTest::addColumn<QDateTime>("dtdue");
 
     // Can't use QDateTime::currentDateTimeUtc() due to milliseconds mismatching
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
     const QDateTime today = QDateTime::fromSecsSinceEpoch(QDateTime::currentSecsSinceEpoch(), Qt::UTC);
+#else
+    qint64 msecs = QDateTime::currentMSecsSinceEpoch() / 1000;
+    const QDateTime today = QDateTime::fromMSecsSinceEpoch(msecs * 1000, Qt::UTC);
+#endif
     const QDateTime tomorrow = today.addDays(1);
     const QDateTime invalid;
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index b0630cdcd..92616cdf7 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -41,23 +41,24 @@ ecm_qt_declare_logging_category(kcalcore_LIB_SRCS
     HEADER kcalendarcore_debug.h
     IDENTIFIER KCALCORE_LOG
     CATEGORY_NAME org.kde.pim.kcalcore
-    OLD_CATEGORY_NAMES log_kcalcore
-    DESCRIPTION "kcalcore (pim lib)"
-    EXPORT KCALENDARCORE
+#    OLD_CATEGORY_NAMES log_kcalcore
+#    DESCRIPTION "kcalcore (pim lib)"
+#    EXPORT KCALENDARCORE
 )
 
 add_library(KF5CalendarCore ${kcalcore_LIB_SRCS})
 add_library(KF5::CalendarCore ALIAS KF5CalendarCore)
 
-ecm_generate_export_header(KF5CalendarCore
-    BASE_NAME kcalendarcore
-    GROUP_BASE_NAME KF
-    VERSION ${KF5_VERSION}
-    DEPRECATED_BASE_VERSION 0
-    DEPRECATION_VERSIONS 5.64
-    EXCLUDE_DEPRECATED_BEFORE_AND_AT ${EXCLUDE_DEPRECATED_BEFORE_AND_AT}
-)
-
+#ecm_generate_export_header(KF5CalendarCore
+#    BASE_NAME kcalendarcore
+#    GROUP_BASE_NAME KF
+#    VERSION ${KF5_VERSION}
+#    DEPRECATED_BASE_VERSION 0
+#    DEPRECATION_VERSIONS 5.64
+#    EXCLUDE_DEPRECATED_BEFORE_AND_AT ${EXCLUDE_DEPRECATED_BEFORE_AND_AT}
+#)
+generate_export_header(KF5CalendarCore
+    BASE_NAME kcalendarcore)
 
 # backward compatibility with the old name
 if (NOT KCALENDARCORE_NO_DEPRECATED_NAMESPACE)
@@ -163,11 +164,11 @@ if (NOT KCALENDARCORE_NO_DEPRECATED_NAMESPACE)
   )
 endif()
 
-ecm_qt_install_logging_categories(
-    EXPORT KCALENDARCORE
-    FILE kcalendarcore.categories
-    DESTINATION ${KDE_INSTALL_LOGGINGCATEGORIESDIR}
-)
+#ecm_qt_install_logging_categories(
+#    EXPORT KCALENDARCORE
+#    FILE kcalendarcore.categories
+#    DESTINATION ${KDE_INSTALL_LOGGINGCATEGORIESDIR}
+#)
 
 ecm_generate_pri_file(BASE_NAME KCalendarCore LIB_NAME KF5CalendarCore DEPS "Core" FILENAME_VAR PRI_FILENAME INCLUDE_INSTALL_DIR ${KDE_INSTALL_INCLUDEDIR_KF5}/KCalendarCore/KCalendarCore)
 install(FILES ${PRI_FILENAME} DESTINATION ${ECM_MKSPECS_INSTALL_DIR})
diff --git a/src/calendar.cpp b/src/calendar.cpp
index 267031ec5..87489a677 100644
--- a/src/calendar.cpp
+++ b/src/calendar.cpp
@@ -27,6 +27,7 @@
 #include "icaltimezones_p.h"
 #include "sorting.h"
 #include "visitor.h"
+#include "utils_p.h"
 
 #include "kcalendarcore_debug.h"
 
diff --git a/src/icalformat.cpp b/src/icalformat.cpp
index 6ea563e9a..6593db302 100644
--- a/src/icalformat.cpp
+++ b/src/icalformat.cpp
@@ -22,6 +22,7 @@
 #include "memorycalendar.h"
 #include "kcalendarcore_debug.h"
 #include "calendar_p.h"
+#include "utils_p.h"
 
 #include <QSaveFile>
 #include <QFile>
diff --git a/src/icalformat_p.cpp b/src/icalformat_p.cpp
index 62ab47db8..f1de95ac5 100644
--- a/src/icalformat_p.cpp
+++ b/src/icalformat_p.cpp
@@ -32,6 +32,7 @@
 #include "memorycalendar.h"
 #include "todo.h"
 #include "visitor.h"
+#include "utils_p.h"
 
 #include "kcalendarcore_debug.h"
 
@@ -2557,7 +2558,9 @@ QDateTime ICalFormatImpl::readICalDateTimeProperty(icalproperty *p, const ICalTi
             break;
         }
     } //end of ICAL_X_PROPERTY
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
     Q_FALLTHROUGH();
+#endif
     default:
         switch (kind) {
         case ICAL_RDATE_PROPERTY:
diff --git a/src/memorycalendar.cpp b/src/memorycalendar.cpp
index 7b52f502d..51cfac413 100644
--- a/src/memorycalendar.cpp
+++ b/src/memorycalendar.cpp
@@ -209,8 +209,8 @@ bool MemoryCalendar::deleteIncidence(const Incidence::Ptr &incidence)
     removeRelations(incidence);
     const Incidence::IncidenceType type = incidence->type();
     const QString uid = incidence->uid();
-    auto incidenceIt = d->mIncidences[type].constFind(uid);
-    if (incidenceIt != d->mIncidences[type].cend()) {
+    auto incidenceIt = d->mIncidences[type].find(uid);
+    if (incidenceIt != d->mIncidences[type].end()) {
         // Notify while the incidence is still available,
         // this is necessary so korganizer still has time to query for exceptions
         notifyIncidenceAboutToBeDeleted(incidence);
diff --git a/src/occurrenceiterator.cpp b/src/occurrenceiterator.cpp
index 82d9964f9..76b352546 100644
--- a/src/occurrenceiterator.cpp
+++ b/src/occurrenceiterator.cpp
@@ -19,6 +19,7 @@
 #include "occurrenceiterator.h"
 #include "calendar.h"
 #include "calfilter.h"
+#include "utils_p.h"
 
 #include <QDate>
 
diff --git a/src/recurrence.cpp b/src/recurrence.cpp
index a685a534f..7ac18ed95 100644
--- a/src/recurrence.cpp
+++ b/src/recurrence.cpp
@@ -137,7 +137,6 @@ bool Recurrence::operator==(const Recurrence &recurrence) const
     return *d == *recurrence.d;
 }
 
-#if KCALENDARCORE_BUILD_DEPRECATED_SINCE(5, 64)
 Recurrence &Recurrence::operator=(const Recurrence &recurrence)
 {
     // check for self assignment
@@ -150,7 +149,6 @@ Recurrence &Recurrence::operator=(const Recurrence &recurrence)
     *d = *recurrence.d;
     return *this;
 }
-#endif
 
 void Recurrence::addObserver(RecurrenceObserver *observer)
 {
diff --git a/src/recurrence.h b/src/recurrence.h
index 2d728c138..720a2f02b 100644
--- a/src/recurrence.h
+++ b/src/recurrence.h
@@ -133,18 +133,13 @@ public:
         return !operator==(r);
     }
 
-#if KCALENDARCORE_BUILD_DEPRECATED_SINCE(5, 64)
     /**
       Assignment operator.
       @param r the recurrence which will be assigned to this.
       @deprecated Do not use, will be removed in KF6
       @warning Broken implementation, do not use!
     */
-    KCALENDARCORE_DEPRECATED_VERSION(5, 64, "Do not use")
     Recurrence &operator=(const Recurrence &r);
-#else
-    Recurrence &operator=(const Recurrence &r) = delete;
-#endif
 
     /** Return the start date/time of the recurrence (Time for all-day recurrences will be 0:00).
      @return the current start/time of the recurrence. */
diff --git a/src/recurrencerule.cpp b/src/recurrencerule.cpp
index cf009a6d9..5a70da143 100644
--- a/src/recurrencerule.cpp
+++ b/src/recurrencerule.cpp
@@ -655,19 +655,29 @@ bool Constraint::readDateTime(const QDateTime &dt, RecurrenceRule::PeriodType ty
     // Really fall through! Only weekly needs to be treated differently!
     case RecurrenceRule::rSecondly:
         second = dt.time().second();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case RecurrenceRule::rMinutely:
         minute = dt.time().minute();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case RecurrenceRule::rHourly:
         hour = dt.time().hour();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case RecurrenceRule::rDaily:
         day = dt.date().day();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case RecurrenceRule::rMonthly:
         month = dt.date().month();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case RecurrenceRule::rYearly:
         year = dt.date().year();
         break;
@@ -1262,29 +1272,39 @@ void RecurrenceRule::Private::buildConstraints()
                 mByYearDays.isEmpty() && mByMonths.isEmpty()) {
             fixConstraint(setMonth, mDateStart.date().month());
         }
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rMonthly:
         if (mByDays.isEmpty() && mByWeekNumbers.isEmpty() &&
                 mByYearDays.isEmpty() && mByMonthDays.isEmpty()) {
             fixConstraint(setDay, mDateStart.date().day());
         }
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rWeekly:
     case rDaily:
         if (mByHours.isEmpty()) {
             fixConstraint(setHour, mDateStart.time().hour());
         }
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rHourly:
         if (mByMinutes.isEmpty()) {
             fixConstraint(setMinute, mDateStart.time().minute());
         }
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rMinutely:
         if (mBySeconds.isEmpty()) {
             fixConstraint(setSecond, mDateStart.time().second());
         }
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rSecondly:
     default:
         break;
@@ -1845,10 +1865,14 @@ Constraint RecurrenceRule::Private::getPreviousValidDateInterval(const QDateTime
     // by the factor 60 and 60*60! Same for weekly and daily (factor 7)
     case rHourly:
         modifier *= 60;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rMinutely:
         modifier *= 60;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rSecondly:
         periods = static_cast<int>(start.secsTo(toDate) / modifier);
         // round it down to the next lower multiple of frequency:
@@ -1861,7 +1885,9 @@ Constraint RecurrenceRule::Private::getPreviousValidDateInterval(const QDateTime
         toDate = toDate.addDays(-(7 + toDate.date().dayOfWeek() - mWeekStart) % 7);
         start = start.addDays(-(7 + start.date().dayOfWeek() - mWeekStart) % 7);
         modifier *= 7;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rDaily:
         periods = start.daysTo(toDate) / modifier;
         // round it down to the next lower multiple of frequency:
@@ -1920,10 +1946,14 @@ Constraint RecurrenceRule::Private::getNextValidDateInterval(const QDateTime &dt
     // by the factor 60 and 60*60! Same for weekly and daily (factor 7)
     case rHourly:
         modifier *= 60;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rMinutely:
         modifier *= 60;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rSecondly:
         periods = static_cast<int>(start.secsTo(toDate) / modifier);
         periods = qMax(0L, periods);
@@ -1937,7 +1967,9 @@ Constraint RecurrenceRule::Private::getNextValidDateInterval(const QDateTime &dt
         toDate = toDate.addDays(-(7 + toDate.date().dayOfWeek() - mWeekStart) % 7);
         start = start.addDays(-(7 + start.date().dayOfWeek() - mWeekStart) % 7);
         modifier *= 7;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 8, 0))
         Q_FALLTHROUGH();
+#endif
     case rDaily:
         periods = start.daysTo(toDate) / modifier;
         periods = qMax(0L, periods);
diff --git a/src/utils_p.h b/src/utils_p.h
index c2ae0e3e0..b205877d3 100644
--- a/src/utils_p.h
+++ b/src/utils_p.h
@@ -29,6 +29,14 @@ void deserializeQDateTimeList(QDataStream &in, QList<QDateTime> &list);
 void serializeQTimeZoneAsSpec(QDataStream &out, const QTimeZone &tz);
 void deserializeSpecAsQTimeZone(QDataStream &in, QTimeZone &tz);
 
+#if (QT_VERSION < QT_VERSION_CHECK(5, 7, 0))
+template <typename T>
+const T& qAsConst(T &t)
+{
+  return const_cast<const T&>(t);
+}
+#endif
+
 }
 
 #endif
-- 
2.17.1

